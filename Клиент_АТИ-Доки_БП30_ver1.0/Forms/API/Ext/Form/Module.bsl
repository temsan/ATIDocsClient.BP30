
// Подключаемые модули
&НаКлиенте
Перем JSON Экспорт;

&НаКлиенте
Перем Служебный Экспорт;

&НаКлиенте
Перем ИмяМодуляУправлениеВзаиморасчетами Экспорт;

&НаКлиенте
Перем ИмяМодуляЭлектронноеВзаимодействиеСлужебныйВызовСервера Экспорт;

////////////////////////////////////////////////////////////////////////////////
// ЛОГИКА НА СТОРОНЕ КЛИЕНТА


&НаКлиенте
Функция ПолучитьСоединение()
	Если ВладелецФормы.ИспользоватьЗащищенноеСоединение Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL();
		Соединение = Новый HTTPСоединение(ВладелецФормы.АдресСервера,,,,,,ЗащищенноеСоединение);
	Иначе
		Соединение = Новый HTTPСоединение(ВладелецФормы.АдресСервера);
	КонецЕсли;
	Возврат Соединение;
КонецФункции

//Вызов операций сервиса типа GET

&НаКлиенте
Функция Search(Строка) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/search/"+Строка+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Search: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Search: "+Результат1С.reason, Строка);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];

КонецФункции

&НаКлиенте
Функция Mailbox() Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/next/mailbox/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Mailbox: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Mailbox: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];

КонецФункции	

&НаКлиенте
Функция Documents(ИмяПапки, Сдвиг, КоличествоДокументов, Маска="") Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/next/mailbox/"+ИмяПапки+"/?limit="+Формат(КоличествоДокументов, "ЧГ=0")+"&offset="+Формат(Сдвиг, "ЧН=0; ЧГ=0")+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Если ЗначениеЗаполнено(Маска) И НЕ(Найти(РезультатJSON, Маска) ИЛИ Найти(РезультатJSON, СтрЗаменить(Маска, " ", ""))) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Documents: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
		
	Результат1С = JSON.РазобратьJSON(РезультатJSON);
	
	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Documents: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];

КонецФункции

//Вызов операций сервиса типа PUT
&НаКлиенте
Процедура Archive(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/archive/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Archive: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат;
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция Unarchive(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;	
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/unarchive/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Unarchive: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Процедура Delete(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/delete/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Delete: "+Ответ.КодСостояния, id);
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция Undelete(id) Экспорт
	
	Соединение = ПолучитьСоединение();

	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/undelete/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Undelete: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Процедура Read(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/read/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Read: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ExportDoc(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("q", "0.01");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/export/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Ошибка получения содержимого вложения по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "ExportDoc: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "ExportDoc: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];

КонецФункции
	
&НаКлиенте
Функция Sign(id, СертификатСсылка) Экспорт
	
	СодержимоеДокумента = ExportDoc(id);
	
	Если СодержимоеДокумента = Неопределено ИЛИ НЕ ЗначениеЗаполнено(СертификатСсылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДанныеПодписиСтрокой = ПодписатьНаКлиенте(СодержимоеДокумента, СертификатСсылка);	
	
	Если ДанныеПодписиСтрокой = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураПодписи = Новый Структура;
	СтруктураПодписи.Вставить("sign", ДанныеПодписиСтрокой);
	СтруктураПодписиJSON = JSON.Значение1С_JSON(СтруктураПодписи);
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("q", "0.01");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/sign/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки(СтруктураПодписиJSON, "CESU-8");
	
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Сообщить("Документ не подписан по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Sign: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить("Документ не подписан по причине: "+Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Sign: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

	//РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	//Результат1С = ЭтотОбъект.JSON.РазобратьJSON(РезультатJSON);
	//Если Результат1С.Свойство("ok") Тогда
	//	Сообщить("Документ успешно подписан");
	//	Возврат Истина;
	//Иначе
	//	Если Результат1С.Свойство("Reason") Тогда
	//		Причина = Результат1С["Reason"];
	//	Иначе
	//		Причина = "Неизвестная причина";
	//	КонецЕсли;
	//	Сообщить("Документ не подписан по причине: "+Причина);
	//	Возврат Ложь;
	//КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция Account(id=0) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	
	Если id=0 Тогда
		Запрос = Новый HTTPЗапрос("/api/account/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	Иначе	
		Запрос = Новый HTTPЗапрос("/api/accounts/"+Формат(id, "ЧГ=0")+"/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	КонецЕсли;
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С.Получить("reason"));
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Account: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Ошибка = Результат1С.Получить("error");
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Account: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
		
КонецФункции

&НаКлиенте
Функция References() Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/references/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "References: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "References: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
		
КонецФункции

&НаКлиенте
Функция Cities(id = Неопределено) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Если ЗначениеЗаполнено(id) Тогда
		Запрос = Новый HTTPЗапрос("/api/references/cities/"+Формат(id, "ЧГ=0")+"/", ЗаголовкиHTTP);
	Иначе
		Запрос = Новый HTTPЗапрос("/api/references/cities/", ЗаголовкиHTTP);
	КонецЕсли;
	
	Ответ = Соединение.Получить(Запрос);
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Cities: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Если Результат1С.Получить("error") = Истина Тогда
		reason = Результат1С["reason"];
		Сообщить(reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Cities: "+reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
		
КонецФункции

&НаКлиенте
Функция Document(id, ВыводитьОшибки = Истина) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Если ВыводитьОшибки Тогда
			Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Document: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		
		Если ВыводитьОшибки Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Document: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;	
	
	Возврат Результат1С["result"];

КонецФункции

&НаКлиенте
Функция GetAttachment(id, File_id, Расширение = "doc", ИмяФайла = "") Экспорт
	
	Если НЕ ЗначениеЗаполнено(File_id) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ИмяФайла = "" Тогда
		ИмяВыходногоФайла = ПолучитьИмяВременногоФайла(Расширение);
	Иначе
		ИмяВыходногоФайла = КаталогВременныхФайлов()+ИмяФайла;
	КонецЕсли;
	
	Соединение = ПолучитьСоединение();

	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/attachments/"+File_id+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "GetAttachment: "+Ответ.КодСостояния, id);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;

	Если ИмяВыходногоФайла = Неопределено Тогда
		
		ОписаниеФайла = Ответ.Заголовки["Content-Disposition"];
		Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ОписаниеФайла, ";");
		Для Каждого Элемент Из Массив Цикл
			Если Лев(Элемент, 9) = "filename=" Тогда
				
				ИмяВыходногоФайла = СтрЗаменить(СтрЗаменить(Сред(Элемент, 10), """", ""), "utf-8", "");
				
				ИмяВыходногоФайла = КаталогВременныхФайлов() + ИмяВыходногоФайла;
				
				Прервать;
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	ОтветДД = Ответ.ПолучитьТелоКакДвоичныеДанные();
	ОтветДД.Записать(ИмяВыходногоФайла);
	
	Возврат ИмяВыходногоФайла;

КонецФункции

&НаКлиенте
Функция GetZip_Archive(id, ИмяФайла) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если ИмяФайла = "" Тогда
		ИмяВыходногоФайла = Неопределено;
	Иначе
		ИмяВыходногоФайла = КаталогВременныхФайлов()+ИмяФайла+".zip";
	КонецЕсли;

	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/zip_archive/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		//Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Ошибка загрузки архива: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "GetZip_Archive: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "GetZip_Archive: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Если ИмяВыходногоФайла = Неопределено Тогда
		
		ОписаниеФайла = Ответ.Заголовки["Content-Disposition"];
		Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ОписаниеФайла, ";");
		Для Каждого Элемент Из Массив Цикл
			Если Лев(Элемент, 9) = "filename=" Тогда
				
				ИмяВыходногоФайла = СтрЗаменить(СтрЗаменить(Сред(Элемент, 10), """", ""), "utf-8", "");
				
				ИмяВыходногоФайла = КаталогВременныхФайлов() + ИмяВыходногоФайла;
				
				Прервать;
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	ОтветДД = Ответ.ПолучитьТелоКакДвоичныеДанные();
	ОтветДД.Записать(ИмяВыходногоФайла);
	
	Возврат ИмяВыходногоФайла;

КонецФункции

&НаКлиенте
Функция PostDocument(СтруктураДокумента) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/", ЗаголовкиHTTP);
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураДокумента);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "PostDocument: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить("ID документа: " + СтруктураДокумента.id);
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "PostDocument: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
		
КонецФункции

&НаКлиенте
Функция PostAttachment(id, ПолноеИмяФайла = "", ДокументСсылка = Неопределено) Экспорт
	
	Файл = Новый Файл(ПолноеИмяФайла);
	ИмяФайла = Файл.Имя;
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "multipart/form-data; charset=windows-1251; boundary="+Boundary);
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	ИмяФайлаОтправки = ПолучитьИмяВременногоФайла("out");
	
	МассивФайлов = Новый Массив;
	
	// Формируем заголовки с помощью текстового документа
	ИмяФайлаГраницНачало = ПолучитьИмяВременногоФайла("txt");
	ФайлГраниц = Новый ЗаписьТекста(ИмяФайлаГраницНачало, "CESU-8");
	
	ФайлГраниц.ЗаписатьСтроку("--" + Boundary);
	ФайлГраниц.ЗаписатьСтроку("Content-Disposition: form-data; name=""file_upload""; filename=""" + ИмяФайла + """");
	ФайлГраниц.ЗаписатьСтроку("");
	ФайлГраниц.Закрыть();
	
	МассивФайлов.Добавить(ИмяФайлаГраницНачало);
	МассивФайлов.Добавить(ПолноеИмяФайла);
	
	ИмяФайлаГраницКонец = ПолучитьИмяВременногоФайла("txt");
	ФайлГраниц = Новый ЗаписьТекста(ИмяФайлаГраницКонец, "CESU-8");
	ФайлГраниц.ЗаписатьСтроку("");
	ФайлГраниц.ЗаписатьСтроку("--" + Boundary + "--");
	ФайлГраниц.Закрыть();
	
	МассивФайлов.Добавить(ИмяФайлаГраницКонец);
	
	ОбъединитьФайлы(МассивФайлов, ИмяФайлаОтправки);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/attachments/", ЗаголовкиHTTP);
	
	Запрос.УстановитьИмяФайлаТела(ИмяФайлаОтправки);
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	Соединение = Неопределено;
	Запрос = Неопределено;
	
	УдалитьФайлы(ИмяФайлаОтправки);
	УдалитьФайлы(ИмяФайлаГраницНачало);
	УдалитьФайлы(ИмяФайлаГраницКонец);
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "PostAttachment: "+Ответ.КодСостояния, id);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "PostAttachment: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
		
КонецФункции

&НаКлиенте
Функция SendDocument(id, doc_recipient_id, doc_recipient_Contact="0") Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/send/", ЗаголовкиHTTP);
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("doc_recipient_id", Формат(doc_recipient_id, "ЧН=0; ЧГ=0"));
	Если doc_recipient_Contact = "0" Тогда
		doc_recipient_Contact = Формат(doc_recipient_id, "ЧН=0; ЧГ=0") + ".0";
	КонецЕсли;
	СтруктураЗапроса.Вставить("doc_recipient_contact", doc_recipient_Contact);
	
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураЗапроса);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Ответ = Соединение.Записать(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "SendDocument: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат Ложь; //Неопределено;
		
	КонецЕсли;
	
	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "SendDocument: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь; //Неопределено;
	КонецЕсли;
	
	Возврат Истина;
		
КонецФункции

&НаКлиенте
Функция Approve(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/approve/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	Если Ответ.КодСостояния<>200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Approve: "+Ответ.КодСостояния, id);
		КонецЕсли;
		Возврат Ложь; //Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С.Получить("error");
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Approve: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь; //Неопределено;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте
Функция Decline(id, Причина="") Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/decline/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки("");
	Ответ = Соединение.Записать(Запрос);
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Decline: "+Ответ.КодСостояния, id);
		КонецЕсли;
		Возврат Ложь; //Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Decline: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь; //Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Причина) Тогда
		Comment(id, Причина);
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте
Функция Comment(id, Комментарий, ФайлИмя = "") Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "multipart/form-data; charset=windows-1251; boundary="+Boundary);
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	ИмяФайлаОтправки = ПолучитьИмяВременногоФайла("out");
	
	МассивФайлов = Новый Массив;
	
	// Формируем заголовки с помощью текстового документа
	ИмяФайлаГраницНачало = ПолучитьИмяВременногоФайла("txt");
	ФайлГраниц = Новый ЗаписьТекста(ИмяФайлаГраницНачало, "CESU-8");
	
	ФайлГраниц.ЗаписатьСтроку("--" + Boundary);
	ФайлГраниц.ЗаписатьСтроку("Content-Disposition: form-data; name = ""comment-text""");
	ФайлГраниц.ЗаписатьСтроку("");
	ФайлГраниц.ЗаписатьСтроку(Комментарий);
	ФайлГраниц.Закрыть();
	
	МассивФайлов.Добавить(ИмяФайлаГраницНачало);
	
	ФлагВложение = Ложь;
	Если ЗначениеЗаполнено(ФайлИмя) Тогда
		Файл = Новый Файл(ФайлИмя);
		Если Файл.Существует() Тогда
			
			ФлагВложение = Истина;
			ВложениеИмяФайлаГраницНачало = ПолучитьИмяВременногоФайла("txt");
			ФайлГраниц = Новый ЗаписьТекста(ВложениеИмяФайлаГраницНачало, "CESU-8");
			
			ФайлГраниц.ЗаписатьСтроку("--" + Boundary);
			ФайлГраниц.ЗаписатьСтроку("Content-Disposition: form-data; name = ""comment-attachment""; filename = """+Файл.Имя+"""");
			ФайлГраниц.ЗаписатьСтроку("");
			ФайлГраниц.Закрыть();
			
			МассивФайлов.Добавить(ВложениеИмяФайлаГраницНачало);
			МассивФайлов.Добавить(ФайлИмя);
			
			ВложениеИмяФайлаГраницКонец = ПолучитьИмяВременногоФайла("txt");
			ФайлГраниц = Новый ЗаписьТекста(ВложениеИмяФайлаГраницКонец, "CESU-8");
			ФайлГраниц.ЗаписатьСтроку("");
			ФайлГраниц.ЗаписатьСтроку("--" + Boundary + "--");
			ФайлГраниц.Закрыть();
			
		КонецЕсли;
	КонецЕсли;
	
	ИмяФайлаГраницКонец = ПолучитьИмяВременногоФайла("txt");
	ФайлГраниц = Новый ЗаписьТекста(ИмяФайлаГраницКонец, "CESU-8");
	ФайлГраниц.ЗаписатьСтроку("");
	ФайлГраниц.ЗаписатьСтроку("--" + Boundary + "--");
	ФайлГраниц.Закрыть();
	
	МассивФайлов.Добавить(ИмяФайлаГраницКонец);
	
	ОбъединитьФайлы(МассивФайлов, ИмяФайлаОтправки);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/comments/", ЗаголовкиHTTP);
	
	Запрос.УстановитьИмяФайлаТела(ИмяФайлаОтправки);
	
	Попытка
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Соединение = Неопределено;
	Запрос = Неопределено;
	
	УдалитьФайлы(ИмяФайлаГраницНачало);
	УдалитьФайлы(ИмяФайлаГраницКонец);
	УдалитьФайлы(ИмяФайлаОтправки);
	
	Если ФлагВложение Тогда
		УдалитьФайлы(ВложениеИмяФайлаГраницНачало);
		УдалитьФайлы(ВложениеИмяФайлаГраницКонец);
	КонецЕсли;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		//Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Ошибка при вложении в комментарий: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Comment: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Comment: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Процедура TestSign(id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("q", "0.01");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+id+"/zip_archive/?base64=true/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	ТипКонтента = Ответ.Заголовки["Content-Type"];
	Если ТипКонтента = "application/json" Тогда
		Попытка
			РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
			Результат1С = JSON.РазобратьJSON(РезультатJSON);
		Исключение
		КонецПопытки;
	КонецЕсли;	
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "TestSign: "+Ответ.КодСостояния, id);
		КонецЕсли;
		
		Возврат;
	КонецЕсли;
	
	ОтветДД = Ответ.ПолучитьТелоКакДвоичныеДанные();
	ИмяФайлаZip = ПолучитьИмяВременногоФайла("zip");
	ОтветДД.Записать(ИмяФайлаZip);
	
	КаталогДляРаспаковки = СформироватьВременныйКаталог();
	ЧтениеZip = Новый ЧтениеZipФайла(ИмяФайлаZip);
	ЧтениеZip.ИзвлечьВсе(КаталогДляРаспаковки);
	
	МассивФайлов = НайтиФайлы(КаталогДляРаспаковки, "*.*");
	
	МассивПодписей = Новый Массив;
	
	Для Каждого Файл Из МассивФайлов Цикл
		Если Файл.Расширение = ".sig" ИЛИ Файл.Расширение = ".sgn" Тогда
			МассивПодписей.Добавить(Файл.ПолноеИмя);
		Иначе
			ФайлДанных = Файл.ПолноеИмя;
		КонецЕсли;
	КонецЦикла;
	
	ПроверитьПодписьНаКлиенте(МассивПодписей, ФайлДанных);
	
КонецПроцедуры

&НаКлиенте
Функция GetSign(Doc_id, File_id, Sign_id) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("q", "0.01");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/documents/"+Doc_id+"/attachments/"+File_id+"/sign/"+Sign_id+"/?base64", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "get_sign: "+Ответ.КодСостояния, Doc_id);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	ОтветДД = Ответ.ПолучитьТелоКакДвоичныеДанные();
	ИмяФайлаSig = ПолучитьИмяВременногоФайла("sig");
	ОтветДД.Записать(ИмяФайлаSig);

	Возврат ИмяФайлаSig;
	
КонецФункции

&НаКлиенте
Функция Trace(Level="Error", Message, Trace="") Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	СтруктураЛога = Новый Структура;
	СтруктураЛога.Вставить("Level", Level);
	СтруктураЛога.Вставить("Message", Message);
	СтруктураЛога.Вставить("Trace", Trace);
	
	Запрос = Новый HTTPЗапрос("/api/trace/", ЗаголовкиHTTP);
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураЛога);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	Возврат Ответ;
		
КонецФункции

&НаКлиенте
Функция GetToken(Логин, Пароль) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json, */*");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	
	СтруктураАвторизации = Новый Структура;
	СтруктураАвторизации.Вставить("login", Логин);
	СтруктураАвторизации.Вставить("password", Пароль);
	
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураАвторизации);
	
	Запрос = Новый HTTPЗапрос("/api/token/", ЗаголовкиHTTP);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, КодировкаТекста.ANSI);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Попытка
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Исключение
		Сообщить(Служебный.ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
		Возврат Неопределено;
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С.Получить("reason"));
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "GetToken: "+Ответ.КодСостояния, Логин);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;

	Ошибка = Результат1С["error"];
	Если Ошибка <> Неопределено И Ошибка Тогда
		Сообщить(Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "References: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"]["id"];
		
КонецФункции

&НаКлиенте
Функция Certificate_Create(СертификатСсылка) Экспорт
	
	//Формируем POST запрос на url /api/next/invoicing/diadoc/certificates/ с телом запроса в виде json объекта содержащий два поля sign и data. В data записываем текущий id аккаунта, в sign подпись текущего id аккаунта необходимым сертификатом. В качестве ответа в случае успеха придет ид сертификата и зашифрованный токен ДиаДок.
	//Пример запроса
	//POST /api/next/invoicing/diadoc/certificates/
	// 
	//Content
	//{
	//    "sign": "fjasdlkfjaslkdjfasdfasdfasdfasdf",
	//    "data": "2483"
	//}
	//Пример ответа
	//{
	//    "fingerprint": "12367ASDADAD",
	//    "token": "ASIODOASDUasodiausd=="
	//}
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПодписываемыеДанные = "test data";
	
	Попытка
		ДанныеПодписиСтрокой = ПодписатьНаКлиенте(ПодписываемыеДанные, СертификатСсылка);
	Исключение
		Сообщить(ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("sign", ДанныеПодписиСтрокой);
	СтруктураЗапроса.Вставить("data", Формат(ВладелецФормы.UserID, "ЧГ=0"));
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	//Изменено: artem.b 17.08.2015
	//Запрос = Новый HTTPЗапрос("/api/certificates/ifns/?token="+token, ЗаголовкиHTTP);
	//---- Заменено на: ----
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/certificates/", ЗаголовкиHTTP);
	/// artem.b 17.08.2015
	
	Запрос.УстановитьТелоИзСтроки(JSON.Значение1С_JSON(СтруктураЗапроса), "CESU-8");
	
	Попытка
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Исключение
	    Возврат Ложь
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Create: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Ошибка = Результат1С["error"];
	Если Ошибка = Истина Тогда
		Сообщить("Сертификат не загружен по причине: "+Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Create: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции
&НаКлиенте
Функция Certificate_Delete(Отпечаток) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/next/certificates/"+Отпечаток+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Удалить(Запрос);
	Исключение
		Сообщить(ОписаниеОшибки());
		Возврат Ложь
	КонецПопытки;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Delete: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
	
	Ошибка = Результат1С["error"];
	Если Ошибка = Истина Тогда
		Сообщить("Сертификат не загружен по причине: "+Результат1С["reason"]);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Delete: "+Результат1С["reason"]);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции


// Функция - Certificates get
// Возвращает коллекцию сертификатов нашего аккаунта
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция Certificates_Get() Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/next/certificates/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Сертификаты не найдены по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificates_Get: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "certificates_get: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция Certificates(AccountID) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	Запрос = Новый HTTPЗапрос("/api/next/accounts/"+Формат(AccountID, "ЧГ=0")+"/certificates/", ЗаголовкиHTTP);
	
	Ответ = Соединение.Получить(Запрос);
	
	Если Ответ.КодСостояния<>200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "certificates: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Если Результат1С.Получить("error")=Истина Тогда
		reason = Результат1С.Получить("reason");
		Сообщить("Сертификаты не найдены по причине: "+reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificates: "+reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С.Получить("result");
	
КонецФункции

&НаКлиенте
Функция Certificate_MetaData_Get(Отпечаток) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	
	Запрос = Новый HTTPЗапрос("/api/next/certificates/"+Отпечаток+"/meta/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	
	Ответ = Соединение.Получить(Запрос);
	
	Если Ответ.КодСостояния <> 200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_MetaData_Get: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С["error"];
	Если Ошибка = Истина Тогда
		Сообщить("Данные сертификата не получены по причине: "+Результат1С.reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_MetaData_Get: "+Результат1С.reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция Certificate_MetaData_Set(Отпечаток, СвойстваСертификата) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	
	Запрос = Новый HTTPЗапрос("/api/next/certificates/"+Отпечаток+"/meta/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("extra", СвойстваСертификата);
	
	Запрос.УстановитьТелоИзСтроки(JSON.Значение1С_JSON(СтруктураЗапроса), "CESU-8");
	
	Ответ = Соединение.Записать(Запрос);
	
	Попытка
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_MetaData_Set: "+Ответ.КодСостояния, Отпечаток);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;

	Ошибка = Результат1С["error"];
	Если Ошибка = Истина Тогда
		Сообщить("Данные сертификата не назначены по причине: "+Результат1С.reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_MetaData_Set: "+Результат1С.reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция Cabinet(Отпечаток) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	//ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("Content-Type", "text/html; charset=windows-1251");
	
	Запрос = Новый HTTPЗапрос("/api/certificates/"+СокрЛП(Отпечаток)+"/cabinet/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	
	//Запрос.УстановитьТелоИзСтроки("{""FingerPrint"" : """+СокрЛП(Отпечаток)+"""}", КодировкаТекста.ANSI);
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	Если Ответ.КодСостояния<>200 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Cabinet: "+Ответ.КодСостояния);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Ошибка = Результат1С.Получить("error");
	Если Ошибка = Истина Тогда
		Сообщить("Кабинет не создан по причине: "+Результат1С.reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Cabinet: "+Результат1С.reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция Certificate_Token_Get(Отпечаток) Экспорт
	
	//Формируем GET запрос на url /api/next/invoicing/diadoc/token/ с пустым телом и получим json ответ с полем token,
	// в котором хранится зашифрованный токен. В заголовках запроса должен содержаться фингерпринт сертификата,
	// который будет использован для авторизации. Расшифровывать этот токен необходимо с помощью сертификата, ид которого был передан.
	// Полученный расшифрованный токен желательно закешировать. Допустимое время кеширования - 120 минут.
	//
	// Пример запроса
	//GET /api/next/invoicing/diadoc/token/ 
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//В ответ получаем зашифрованный токен ДиаДок
	//Пример ответа
	//{
	//    "token": "2374123987461239874612398712738412987649812736498123764918237641293864"
	//}	
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/token/", ЗаголовкиHTTP);
	
	Ответ = Соединение.Получить(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С.Получить("reason"));
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Token_Get: "+Ответ.КодСостояния, Отпечаток);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;

	Если Результат1С["error"] = Истина Тогда
		reason = Результат1С["reason"];
		Сообщить("Данные сертификата не получены по причине: "+reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Token_Get: "+reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция Certificate_Token_Login(Отпечаток, ТокенДиадок, СвойстваСертификата) Экспорт
	
	//Формируем POST запрос на url /api/next/invoicing/diadoc/account/ с телом запроса в виде json объекта содержащего поле extra, содержащий дополнительные поля, необходимые для регистрации пользователя в ИФНС как участника ЭДО. Сервер производит валидацию extra полей, авторизацию в ДиаДоке и привязку аккаунта ДиаДок к сертификату пользователя АтиДокс. Так же, в случае необходимости происходит отправка заявления на регистрацию участника ЭДО в ИФНС. В случае успеха, в ответ придет текущий статус аккаунта ДиаДок.
	//Описание полей extra
	//ogrn	ОГРН юрлица
	//inn	ИНН юрлица
	//region_code	Код налоговой инспекции по КЛАДР
	// 
	// 
	//Пример запроса
	//POST /api/next/invoicing/diadoc/account/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	// 
	//Content
	//{
	//    "extra":
	//        {      
	//            "ogrn": "234523452345243",
	//            "ifns": "1234",
	//            "region_code": "78"
	//        }
	//}
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/account/", ЗаголовкиHTTP);
	
	Экстра = Новый Структура("ogrn, ifns, region_code");
	ЗаполнитьЗначенияСвойств(Экстра, СвойстваСертификата);
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("extra", Экстра);
	Запрос.УстановитьТелоИзСтроки(JSON.Значение1С_JSON(СтруктураЗапроса), "CESU-8");	
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Token_Login: "+Ответ.КодСостояния, Отпечаток);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;

	Ошибка = Ложь;
	Если Результат1С["error"] = Истина Тогда
		reason = Результат1С.Получить("reason");
		Сообщить(reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificate_Token_Login: "+reason);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте
Функция IFNS(Отпечаток, ТокенДиадок, НовыеСвойства) Экспорт
	
	//Формируем POST запрос на url /api/next/invoicing/diadoc/account/ с телом запроса в виде json объекта содержащего поле extra,
	// содержащий дополнительные поля, необходимые для регистрации пользователя в ИФНС как участника ЭДО.
	// Сервер производит валидацию extra полей, авторизацию в ДиаДоке и привязку аккаунта ДиаДок к сертификату пользователя АтиДокс.
	// Так же, в случае необходимости происходит отправка заявления на регистрацию участника ЭДО в ИФНС. В случае успеха,
	// в ответ придет текущий статус аккаунта ДиаДок.
	// 
	//Описание полей extra
	//ogrn	ОГРН юрлица
	//inn	ИНН юрлица
	//region_code	Код налоговой инспекции по КЛАДР
	// 
	// Пример запроса
	//POST /api/next/invoicing/diadoc/account/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	// 
	//Content
	//{
	//    "extra":
	//        {      
	//            "ogrn": "234523452345243",
	//            "ifns": "1234",
	//            "region_code": "78"
	//        }
	//}
	//
	// В ответ придет текущий статус регистрации
	// 
	// Пример ответа
	//{
	//    "status_code": "activation_pending"
	//}	
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/account/", ЗаголовкиHTTP);
	
	Экстра = Новый Структура("ogrn, ifns, region_code");
	Для Каждого Элемент Из Экстра Цикл
		Экстра.Вставить(Элемент.Ключ, НовыеСвойства[Элемент.Ключ]);
	КонецЦикла;
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("extra", Экстра);
	
	Запрос.УстановитьТелоИзСтроки(JSON.Значение1С_JSON(СтруктураЗапроса), "CESU-8");	
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "IFNS: "+Ответ.КодСостояния, Отпечаток);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Результат1С = JSON.РазобратьJSON(РезультатJSON);

	Если Результат1С["error"] = Истина Тогда
		reason = Результат1С["reason"];
		Сообщить("Кабинет не создан по причине: "+reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "IFNS: "+reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция IFNS_UpdateStatus(Отпечаток, ТокенДиадок) Экспорт
	
	//Формируем GET запрос на URL /api/invoicing/diadoc/account/ с токеном ДиаДок и фингерпринтом сертификата в заголовках запроса.
	//В ответ придет статус кабинета ДиаДок. (список значений статусов)
	//Пример запроса
	//GET /api/invoicing/diadoc/account/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	
	Соединение = ПолучитьСоединение();
	
	Если Соединение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);
		
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/account/", ЗаголовкиHTTP);
	
	Ответ = Соединение.Получить(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "IFNS_UpdateStatus: "+Ответ.КодСостояния, Отпечаток);
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
	Если Результат1С["error"] = Истина Тогда
		reason = Результат1С["reason"];
		Сообщить("Кабинет не создан по причине: "+reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "IFNS_UpdateStatus: "+reason);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

&НаКлиенте
Функция SendInvoice(doc_id, to_box_id, Отпечаток, Invoice_Token) Экспорт
	
	//Пример запроса
	//POST /api/invoicing/diadoc/documents/<doc_id>/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	// 
	//Content
	//{
	//    'to_box_id': box_id получателя (смотри п. 3)

	//}
	//Пример ответа
	//{
	//    "doc_id": "e24141414cbcbcbc34234234aab8374"
	//}
	
	Соединение = ПолучитьСоединение();

	Если Соединение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", Invoice_Token);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/documents/"+doc_id+"/", ЗаголовкиHTTP);
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("to_box_id", Формат(to_box_id, "ЧН=0; ЧГ=0"));
	СтруктураЗапроса.Вставить("token", Invoice_Token);
	
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураЗапроса);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 И Ответ.КодСостояния >= 300 Тогда
		
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
		Если Результат1С <> Неопределено Тогда
			Сообщить(Результат1С["reason"]);
		КонецЕсли;
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "SendInvoice: "+Ответ.КодСостояния, doc_id);
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Ошибка = Ложь;
	Если Результат1С <> Неопределено И Результат1С.Получить("error") = Истина Тогда
		reason = Результат1С.Получить("reason");
		Сообщить(reason);
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "SendInvoice: "+reason);
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
		
КонецФункции

// Функция - Notifications_Get
// Возвращает коллекцию сервисных сообщений Диадок
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция Notifications_Get(ТокенДиадок, Отпечаток) Экспорт
	
	//Пример запроса
	//GET /api/next/invoicing/diadoc/notifications/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	//Пример ответа
	//{
	//"notifications":
	//    [{
	//        'message_id': 'ef12342-1233124',
	//        'entity_id': 'ac8825923-7123312',
	//        'parent_entity_id': 'fe67787-12312',
	//        'document_id': '74fa32ea',
	//        'xml_content': '<xml version="1.0" encoding="windows-1251"?><Файл ИдФайл="DP_IZVPOL_....',
	//        'file_name': 'DP_IZVPOL_2BM-9638795019-963801000-2015021010510176064_2BM-9678093175-967801000-20150210.xml'
	//    },
	//    ...
	//    ],
	//"procesing_errors:" 
	//    [
	//     {
	//        "error_code": 401,
	//        "error_description": "",
	//        "method_name": ""
	//     }, ...
	//    ]
	//}	
		
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);

	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/notifications/", ЗаголовкиHTTP);
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("token", ТокенДиадок);
	СтруктураЗапроса.Вставить("cert_thumbprint", Отпечаток);
	
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураЗапроса);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, КодировкаТекста.ANSI);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		Возврат Неопределено;
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Ошибка загрузки извещений по счетам-фактурам: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Notifications_POST: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Notifications_POST: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

// Функция - Notifications_Sign
//  Подписывает коллекцию сервисных сообщений Диадок
//  
//  Правильно написанная процедура HTTP вызова
//  TODO: Необходимо позже создать обертку по ее подобию
//
// Параметры:
//  Элемент		 - 	 - 
//  Отпечаток	 - 	 - 
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция Notifications_Sign(Элемент, СертификатСсылка) Экспорт
	
	СодержимоеДокумента = Элемент["xml_content"];
	
	ДанныеПодписиСтрокой = ПодписатьНаКлиенте(СодержимоеДокумента, СертификатСсылка);
	
	Если ДанныеПодписиСтрокой = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Элемент.Вставить("signature", ДанныеПодписиСтрокой);
	
	Возврат Истина;
	
КонецФункции

// Функция - Notifications_Put
// Возвращает коллекцию сервисных сообщений Диадок
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция Notifications_Put(ТокенДиадок, Отпечаток, МассивОтветов) Экспорт
	
	//Пример запроса:
	//POST /api/next/invoicing/diadoc/notifications/
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	// 
	//Content
	//{
	//[
	//'token': авторизационный токен ДиаДок,
	//'cert_thumbprint': фингерпринт сертификата, который использовался для получения этого токена,
	//'notifications': [{
	//    'message_id': 'ef12342-1233124',
	//    'entity_id': 'ac8825923-7123312',
	//    'parent_entity_id': 'fe67787-12312',
	//    'document_id': '74fa32ea',
	//    'xml_content': '<xml version="1.0" encoding="windows-1251"?><Файл ИдФайл="DP_IZVPOL_....',
	//    'file_name': 'DP_IZVPOL_2BM-9638795019-963801000-2015021010510176064_2BM-9678093175-967801000-20150210.xml',
	//    'signature': 'NIIIJAash.....asiduasoidu'
	//},
	//...
	//]
	//}		
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);
	
	Запрос = Новый HTTPЗапрос("/api/invoicing/notifications/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	
	СтруктураЗапроса = Новый Структура("token,
		|cert_thumbprint,
		|notifications",
		ТокенДиадок,
		Отпечаток,
		МассивОтветов);
	
	СтрокаЗапроса = JSON.Значение1С_JSON(СтруктураЗапроса);
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса, "CESU-8");
	
	Попытка
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Ошибка отправки извещений о получении счетов-фактур: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Notifications_Response_POST: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Notifications_Response_POST: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

// Функция - DocumentStatus_Get
// Получает статусы счетов-фактур
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция DocumentStatus_Get(Отпечаток, ТокенДиадок, МассивИД) Экспорт
	
	// Пример запроса
	//GET /api/next/invoicing/diadoc/documents/as6376asdfjhsdf,fghjasdhfg678142/
	// 
	//HttpHeaders
	//InvoicingFingerprint: 12367ABCDF23123FF32132BC
	//InvoicingToken: 7cb123c4b1234b123c4b123c4b123c4b123c4b123c4b123c4b12c4b123c4b123c4b123c4b1
	
	СтрокаИД = СтроковыеФункцииКлиентСервер.СтрокаИзМассиваПодстрок(МассивИД, ",");
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадок);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/documents/"+СтрокаИД+"/", ЗаголовкиHTTP);
		
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		//Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Сертификаты не найдены по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificates_Get: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "certificates_get: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

// Функция - counteragents_search
// Возвращает коллекцию сертификатов нашего аккаунта
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция Counteragents_Search(ИНН, КПП = "", ТокенДиадк, Отпечаток) Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json");
	ЗаголовкиHTTP.Вставить("X-Auth-Token", ВладелецФормы.token);
	
	ЗаголовкиHTTP.Вставить("InvoicingToken", ТокенДиадк);
	ЗаголовкиHTTP.Вставить("InvoicingFingerprint", Отпечаток);
	
	Запрос = Новый HTTPЗапрос("/api/next/invoicing/diadoc/organizations/"+ИНН+"/"+КПП+"/", ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Не найден контрагент в ФНС по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Counteragents_Search: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Counteragents_Search: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

// Функция - History
// Возвращает коллекцию сертификатов нашего аккаунта
// 
// Правильно написанная процедура HTTP вызова
// TODO: Необходимо позже создать обертку по ее подобию
// 
// Возвращаемое значение:
//  Ответ - Соответствие
//
&НаКлиенте
Функция History() Экспорт
	
	Соединение = ПолучитьСоединение();
	
	ЗаголовкиHTTP = Новый Соответствие();
	ЗаголовкиHTTP.Вставить("Accept", "application/json");
	ЗаголовкиHTTP.Вставить("Content-Type", "application/json; charset=windows-1251");
	
	Запрос = Новый HTTPЗапрос("/api/certificates/?token="+ВладелецФормы.token, ЗаголовкиHTTP);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
		РезультатJSON = Ответ.ПолучитьТелоКакСтроку();
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	КонецПопытки;
	
	Попытка
		Результат1С = JSON.РазобратьJSON(РезультатJSON);
	Исключение
	КонецПопытки;
	
	Если Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		Сообщить("Ошибка HTTP"+Ответ.КодСостояния);
	КонецЕсли;

	Если Результат1С <> Неопределено И Результат1С["error"] = Истина Тогда
		
		Сообщить("Сертификаты не найдены по причине: "+Результат1С["reason"]);
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "Certificates_Get: "+Результат1С["reason"]);
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли Ответ.КодСостояния < 200 ИЛИ Ответ.КодСостояния >= 300 Тогда
		
		Если ВладелецФормы.ОтправлятьСообщенияОбОшибках Тогда
			Trace("Error", "certificates_get: "+Ответ.КодСостояния);
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Результат1С["result"];
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНАЯ ЛОГИКА

&НаКлиенте
Функция ПолучитьДоступКСертификату(СертификатСсылка) Экспорт
	
	// Запрос пароля
	ПараметрыСертификата = Вычислить(ИмяМодуляЭлектронноеВзаимодействиеСлужебныйВызовСервера).РеквизитыСертификата(СертификатСсылка);
	
	//ОбменСБанкамиСлужебныйКлиент.ПроверитьСрокДействияСертификата(СертификатСсылка);
	
	Соответствие = Новый Соответствие;
	Соответствие.Вставить(СертификатСсылка, ПараметрыСертификата);
	
	Если Не ОбменСКонтрагентамиСлужебныйКлиент.ЕстьСертификатССохраненнымПаролем(Соответствие) Тогда
		
		Пароль = "";
		Если ВвестиЗначение(Пароль, "Ввелите пароль сертификата " + ПараметрыСертификата.Наименование) Тогда
			ПараметрыСертификата.ПарольПолучен = Истина;
			ПараметрыСертификата.ПарольПользователя = Пароль;
			
			Возврат ПараметрыСертификата;
			
		КонецЕсли;
		
	Иначе
		
		Возврат Соответствие[СертификатСсылка];
		
	КонецЕсли;

	// Далее проверки свойств:
	//ПараметрыСертификата.ПарольПолучен
	//ПараметрыСертификата.ПарольПользователя
	
КонецФункции

&НаКлиенте
Функция ПодписатьНаКлиенте(СодержимоеДокумента, СертификатСсылка) Экспорт
	
	ПараметрыСертификата = ПолучитьДоступКСертификату(СертификатСсылка);
	
	Если ТипЗнч(ПараметрыСертификата) <> Тип("Структура") Тогда
		Возврат Неопределено;
	
	ИначеЕсли ПараметрыСертификата.ПарольПолучен Тогда
		
		Если ЭлектроннаяПодписьКлиентСервер.ОбщиеНастройки().СоздаватьЭлектронныеПодписиНаСервере Тогда
			
			Возврат ПодписатьНаСервере(СодержимоеДокумента, СертификатСсылка, ПараметрыСертификата.ПарольПользователя);
			
		Иначе
			
			Возврат ПодписатьНаКлиентеПодпись(СодержимоеДокумента, ПараметрыСертификата);
			
		КонецЕсли;
		
	КонецЕсли;	
	
КонецФункции

&НаКлиенте
Функция ПодписатьНаКлиентеАсинхронно(Результат = Неопределено, Контекст) Экспорт
	
	Если НЕ Контекст.Свойство("Фаза") Тогда
		
		Контекст = Новый Структура("Фаза, СодержимоеДокумента, ПараметрыСертификата",
			"НачалоПодписывания",
			Результат,
			Контекст);

		Оповещение = Новый ОписаниеОповещения("ПодписатьНаКлиентеПодпись", ЭтотОбъект, Контекст);
	    ЭлектроннаяПодписьСлужебныйКлиент.СоздатьМенеджерКриптографии(Оповещение, "Подписание");
		
	ИначеЕсли Контекст.Фаза = "НачалоПодписывания" Тогда
		
		Если ТипЗнч(Результат) = Тип("МенеджерКриптографии") Тогда
			
			МенеджерКриптографии = Результат;
			
			Контекст.Вставить("Фаза", "ПослеПодписания");
			
			Оповещение = Новый ОписаниеОповещения("ПодписатьНаКлиентеПодпись", ЭтотОбъект, Контекст);
			
			МенеджерКриптографии.НачатьПодписывание(Оповещение, Контекст.СодержимоеДокумента, Контекст.ПараметрыСертификата.Отпечаток);
			
		КонецЕсли;
		
	ИначеЕсли Контекст.Фаза = "ПослеПодписания" Тогда	
		
		Если ТипЗнч(Результат) = Тип("ДвоичныеДанные") Тогда
			
			Возврат Base64Строка(Результат);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ПодписатьНаКлиентеПодпись(СодержимоеДокумента, ПараметрыСертификата) Экспорт
	
	Перем ДанныеПодписи;
	Перем ДанныеПодписиСтрокой;
	Перем МенеджерКриптографии;
	Перем Сертификат;
	Перем СодержимоеДокументаДД;
	
	СертификатСсылка = ПараметрыСертификата.ВыбранныйСертификат;
	
	Попытка
		
		Программа = ПолучитьЗначениеРеквизита(СертификатСсылка, "Программа");
		
		РеквизитыПрограммы = ПолучитьЗначенияРеквизитов(Программа, "ИмяПрограммы, ТипПрограммы");
		
		МенеджерКриптографии = Новый МенеджерКриптографии(РеквизитыПрограммы.ИмяПрограммы, "", РеквизитыПрограммы.ТипПрограммы);
		МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = ПараметрыСертификата.ПарольПользователя;
		
		Если ТипЗнч(СертификатСсылка) = Тип("СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования") Тогда
			
			Сертификат = Новый СертификатКриптографии(ПараметрыСертификата.ДвоичныеДанныеСертификата);
			
		КонецЕсли;
		
		СодержимоеДокументаДД = Base64Значение(СодержимоеДокумента);
		ДанныеПодписи = МенеджерКриптографии.Подписать(СодержимоеДокументаДД, Сертификат);
		
		ДанныеПодписиСтрокой = Base64Строка(ДанныеПодписи);
		
		Возврат ДанныеПодписиСтрокой;
		
	Исключение
		
		Возврат Неопределено;
		
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Функция СформироватьВременныйКаталог() Экспорт
	ИмяКаталога = КаталогВременныхФайлов()+"\"+(Новый УникальныйИдентификатор());
	КаталогНаДиске = Новый Файл(ИмяКаталога);
	Если КаталогНаДиске.Существует() Тогда
		УдалитьФайлы(КаталогНаДиске, "*");
	Иначе
		СоздатьКаталог(ИмяКаталога);
	КонецЕсли;
	Возврат ИмяКаталога;
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ЛОГИКА НА СТОРОНЕ СЕРВЕРА

&НаСервере
Функция ПодписатьНаСервере(СодержимоеДокумента, СертификатСсылка, ПарольПользователя)
    
    Перем ДанныеПодписи;
	Перем ДанныеПодписиСтрокой;
	Перем МенеджерКриптографии;
	Перем Сертификат;
	Перем СодержимоеДокументаДД;
	
	Попытка
		
		Если ТипЗнч(СертификатСсылка) = Тип("Строка") Тогда
			
			ОтпечатокСтрока = СертификатСсылка;
			
			СертификатСсылка = Подключение1СТакском.НайтиСертификатПоОтпечатку(Base64Строка(ОтпечатокСтрока));
			
			Если НЕ ЗначениеЗаполнено(СертификатСсылка) Тогда
				
				ТекстовойДокумент = Новый ТекстовыйДокумент;
				ТекстовойДокумент.УстановитьТекст(СертификатСсылка);
				
				ИмяФайла = ПолучитьИмяВременногоФайла("txt");
				
				ТекстовойДокумент.Записать(ИмяФайла);
				
				Фингерпринт = Base64Строка(Новый ДвоичныеДанные(ИмяФайла));
				
				Сертификат = ЭлектроннаяПодпись.ПолучитьСертификатПоОтпечатку(Фингерпринт, Ложь,, Истина);
				Если ЗначениеЗаполнено(Сертификат) Тогда
					СертификатСсылка = Сертификат;
					
				Иначе
					
					МенеджерКриптографии = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии("ПолучениеСертификатов");
					
					ХранилищеСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
					
					Сертификат = ХранилищеСертификатов.НайтиПоОтпечатку(Base64Значение(Фингерпринт));
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Программа = СертификатСсылка.Программа;
			МенеджерКриптографии = Новый МенеджерКриптографии(Программа.ИмяПрограммы, "", Программа.ТипПрограммы);
			МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = ПарольПользователя;
			
		КонецЕсли;
		
		Если ТипЗнч(СертификатСсылка) = Тип("СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования") Тогда
			
			МетаСправочникСертификатов = СертификатСсылка.Метаданные();
			
			Если МетаСправочникСертификатов.Реквизиты.Найти("ДанныеСертификата") <> Неопределено Тогда
				
				ДанныеСертификата = СертификатСсылка.ДанныеСертификата.Получить();
				
			ИначеЕсли МетаСправочникСертификатов.Реквизиты.Найти("ФайлСертификата") <> Неопределено Тогда	
				
				ДанныеСертификата = СертификатСсылка.ФайлСертификата.Получить();
				
			КонецЕсли;
			
			Сертификат = Новый СертификатКриптографии(ДанныеСертификата);
			
		КонецЕсли;
		
		СодержимоеДокументаДД = Base64Значение(СодержимоеДокумента);
		ДанныеПодписи = МенеджерКриптографии.Подписать(СодержимоеДокументаДД, Сертификат);
		
		ДанныеПодписиСтрокой = Base64Строка(ДанныеПодписи);
		
		Возврат ДанныеПодписиСтрокой;
		
	Исключение
		
		Возврат Неопределено;
		
	КонецПопытки;

КонецФункции

&НаКлиенте
Процедура ПроверитьПодписьНаКлиенте(МассивПодписей, ФайлДанных)
	
	Контекст = Новый Структура("МассивПодписей, ФайлДанных",
		МассивПодписей, ФайлДанных);
	
	Оповещение = Новый ОписаниеОповещения("ПроверитьПодписьНаКлиентеЗавершение", ЭтотОбъект, Контекст);
	
	ЭлектроннаяПодписьСлужебныйКлиент.СоздатьМенеджерКриптографии(Оповещение, "ПроверкаПодписи");	
	
КонецПроцедуры

&НаКлиенте
Процедура ПроверитьПодписьНаКлиентеЗавершение(Результат, Контекст) Экспорт
	
	Если ТипЗнч(Результат) = Тип("МенеджерКриптографии") Тогда
		МенеджерКриптографии = Результат;
	Иначе
		Возврат;
	КонецЕсли;
	
	Для Каждого ФайлПодписи Из Контекст.МассивПодписей Цикл
		
		Сертификат = Неопределено;
		
		ТекстПодписи = Новый ЧтениеТекста(ФайлПодписи, КодировкаТекста.ANSI);
		ПодписьСтрокой = ТекстПодписи.Прочитать();
		ПодписьДД = Base64Значение(ПодписьСтрокой);
		
		Попытка
			МенеджерКриптографии.ПроверитьПодпись(Контекст.ФайлДанных, ПодписьДД, Сертификат);
			Сообщить("Тест выполнен");
			Сообщить(ИнформацияОСертификате(Сертификат));
		Исключение
			Попытка
				МенеджерКриптографии.ПроверитьПодпись(Контекст.ФайлДанных, ФайлПодписи, Сертификат);
				Сообщить("Тест выполнен");
				Сообщить(ИнформацияОСертификате(Сертификат));
			Исключение
				Сообщить("Тест не пройден");
			КонецПопытки;
		КонецПопытки;
		
	КонецЦикла;
		
КонецПроцедуры

&НаКлиенте
Функция ИнформацияОСертификате(Сертификат) Экспорт
	
	Результат = "";
	Результат = Результат + "Сертификат выдан: "+ ЭлектроннаяПодписьКлиентСервер.ПредставлениеСубъекта(Сертификат)+Символы.ПС;
	Результат = Результат + "Действителен с: "+Сертификат.ДатаНачала+Символы.ПС;
	Результат = Результат + "Действителен по: "+Сертификат.ДатаОкончания+Символы.ПС;
	
	Возврат Результат;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьОтпечатокСертификатаНаСервере(Сертификат)
	
	Возврат Base64Строка(Сертификат.ДанныеСертификата.Получить());
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита)
	
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьЗначенияРеквизитов(Ссылка, Реквизиты)
	
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты);
	
КонецФункции


